<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Michael Potter</title>
    <link>http://mvpotter.com/tags/springfox/index.xml</link>
    <description>Recent content on Michael Potter</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Michael Potter.</copyright>
    <atom:link href="http://mvpotter.com/tags/springfox/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Springfox plugin for adding auth params</title>
      <link>http://mvpotter.com/post/2016/10/springfox-plugin-for-adding-auth-params/</link>
      <pubDate>Mon, 17 Oct 2016 21:08:31 +0700</pubDate>
      
      <guid>http://mvpotter.com/post/2016/10/springfox-plugin-for-adding-auth-params/</guid>
      <description>&lt;p&gt;Generating REST API documentation using Springfox for one of the recent projects I found out that adding authentication header to private api methods is not an obvious task. In accordance with &lt;a href=&#34;http://springfox.github.io/springfox/docs/current/&#34;&gt;Springfox reference&lt;/a&gt; it could be done using &lt;em&gt;globalOperationParameters&lt;/em&gt;, however in this case parameter will be added to every endpoint. Dilip Krishnan &lt;a href=&#34;http://stackoverflow.com/questions/36475452/reuse-complex-spring-fox-swagger-annotation&#34;&gt;suggests&lt;/a&gt; to create multiple dockets to separate public api from private one. But in my case the only method of public api is &lt;em&gt;/login&lt;/em&gt; and it is not reasonable to create docket for a single endpoint. Thus, I wrote a plugin to solve the issue.

All extensibility points are described in &lt;a href=&#34;http://springfox.github.io/springfox/docs/current/#plugins&#34;&gt;Springfox reference&lt;/a&gt;. As the documentation states plugin should:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Implement one of the extention points.&lt;/li&gt;
&lt;li&gt;Have apprpriate initialization order.&lt;/li&gt;
&lt;li&gt;Be declared as a Spring bean for plugin registry to pick it up.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.springframework.stereotype.Component;
import org.springframework.core.annotation.Order;
import springfox.documentation.spi.service.OperationBuilderPlugin;
import springfox.documentation.swagger.common.SwaggerPluginSupport;

@Component
@Order(SwaggerPluginSupport.SWAGGER_PLUGIN_ORDER)
public class AuthenticationTokenHeaderBuilder implements OperationBuilderPlugin {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In my case the most appropriate extension point is &lt;em&gt;OperationBuilderPlugin&lt;/em&gt; as I need to process each endpoint and add authentication header to private api ones.&lt;/p&gt;

&lt;p&gt;Extension points require two methods to be implemented:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Spring plugin&amp;rsquo;s method &lt;code&gt;boolean supports()&lt;/code&gt; to understand if plugin should be applied. The implementation for Springfox is pretty simple&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public boolean supports(final DocumentationType documentationType) {
    return DocumentationType.SWAGGER_2.equals(documentationType);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Method &lt;code&gt;void apply(context)&lt;/code&gt;, which is being invoked for each api endpoint and provides appropriate context (e.g. &lt;em&gt;OperationContext&lt;/em&gt; for &lt;em&gt;OperationBuilderPlugin&lt;/em&gt;) as an argument.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void apply(final OperationContext context) {
    // Get endpoint request mapping
    final String mapping = context.requestMappingPattern();      
    // Check if private api endpoint    
    if (!PUBLIC_API_MAPPINGS.contains(mapping)) {                    
        final List&amp;lt;Parameter&amp;gt; parameters = new LinkedList&amp;lt;&amp;gt;();
        // Create auth header parameter
        parameters.add(parameterBuilder
                               .parameterType(HEADER_PARAMETER_TYPE)
                               .name(HttpTokenHelper.HEADER_TOKEN)
                               .modelRef(new ModelRef(STRING_TYPE))
                               .description(HEADER_DESCRIPTION)
                               .allowMultiple(false)
                               .required(true)
                             .build());
        // Add parameter to endpoint documentation 
        context.operationBuilder().parameters(parameters);           
      }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a result, every endpoint, except &lt;em&gt;/login&lt;/em&gt; has authentication token header in generated documentation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mvpotter.com/post/2016/10/springfox-plugin-for-adding-auth-params-1.png&#34; alt=&#34;Image&#34; /&gt;
&lt;img src=&#34;http://mvpotter.com/post/2016/10/springfox-plugin-for-adding-auth-params-2.png&#34; alt=&#34;Image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The whole code of the plugin is the following.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.invitro.registry.security.HttpTokenHelper;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import springfox.documentation.builders.ParameterBuilder;
import springfox.documentation.schema.ModelRef;
import springfox.documentation.service.Parameter;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spi.service.OperationBuilderPlugin;
import springfox.documentation.spi.service.contexts.OperationContext;
import springfox.documentation.swagger.common.SwaggerPluginSupport;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

@Component
@Order(SwaggerPluginSupport.SWAGGER_PLUGIN_ORDER)
public class AuthenticationTokenHeaderBuilder implements OperationBuilderPlugin {

    public static final String API_LOGIN_ENDPOINT = &amp;quot;/api/login&amp;quot;;
    public static final String HEADER_PARAMETER_TYPE = &amp;quot;header&amp;quot;;
    public static final String HEADER_DESCRIPTION = &amp;quot;Authentication token (see &amp;quot; + API_LOGIN_ENDPOINT + &amp;quot;)&amp;quot;;
    public static final String STRING_TYPE = &amp;quot;string&amp;quot;;

    private static final List&amp;lt;String&amp;gt; PUBLIC_API_MAPPINGS = Collections.singletonList(API_LOGIN_ENDPOINT);

    private ParameterBuilder parameterBuilder = new ParameterBuilder();

    @Override
    public boolean supports(final DocumentationType documentationType) {
        return DocumentationType.SWAGGER_2.equals(documentationType);
    }

    @Override
    public void apply(final OperationContext context) {
        final String mapping = context.requestMappingPattern();
        if (!PUBLIC_API_MAPPINGS.contains(mapping)) {
            final List&amp;lt;Parameter&amp;gt; parameters = new LinkedList&amp;lt;&amp;gt;();
            parameters.add(parameterBuilder
                                   .parameterType(HEADER_PARAMETER_TYPE)
                                   .name(HttpTokenHelper.HEADER_TOKEN)
                                   .modelRef(new ModelRef(STRING_TYPE))
                                   .description(HEADER_DESCRIPTION)
                                   .allowMultiple(false)
                                   .required(true)
                                   .build());
            context.operationBuilder().parameters(parameters);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>